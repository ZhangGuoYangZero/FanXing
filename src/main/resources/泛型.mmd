Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 泛型

## 泛型类

### 类的泛型需要在实例化的时候指定

### 方法的泛型不需要指定<br/>只要传过去能正常运行

#### 为什么方法的泛型<br/>不需要指定类型？

### 类的泛型静态化

#### 静态属性不能泛型<br/>泛型是在实例化的时候指定<br/>静态属性是随类加载

#### 静态方法和普通方法都可以泛型，<br/>因为方法不属于类

#### 泛型的属性，不能用于各种运算<br/>因为根本不知道是什么类型

## 泛型擦除

### 无论泛型所选的类是什么

#### 他们的字节码文件是一致的

### 泛型只存储于编译阶段

### 在编译成class文件后，泛型就没有了

## 泛型接口

### 接口来源于抽象类<br/>比抽象类还抽象

#### 由于接口只有接口

##### 所以等于方法的运用<br/>接口中的泛型只能作用于参数

## 泛型上下界

### super

#### 作用于方法中<br/>参数上<br/>的类<br/>的泛型

##### 类《? super x, ? super ?》

###### X自身和X的父类<br/>可以使用

##### 使用super无法获取父类的数据<br/>毕竟编译阶段是子类的引用<br/>由于是泛型也没有办法强转<br/>所以根本拿不到父类的数据

#### 作用于非静态属性上的泛型

### extends

#### 作用于方法中<br/>参数上<br/>的类的泛型

##### 类\<? extends y, ? extends y\>

###### y和Y的子类<br/>可以使用

##### 使用extends无法获取子类的数据<br/>毕竟是编译阶段，所以引用指向的是父类<br/>只能拿到父类本身的数据，也用不了强转

#### 作用于非静态属性上的泛型

## 泛型可以传递<br/>只要满足条件就可以

### 如果是在父类引用中添加了泛型

#### 一定要记住外层是符合父类和子类的关系<br/>内部是符合泛型的关系

## ？通配符只能作用域类的参数泛型
